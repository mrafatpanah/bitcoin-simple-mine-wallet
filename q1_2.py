# -*- coding: utf-8 -*-
"""q1_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IrA4b8MM1Ej5-l9xR_yT2aZzXdfuIOMa
"""

#!apt-get install libgmp-dev
#!pip install fastecdsa
#!pip install base58check

import random,hashlib,base58check
from fastecdsa import keys,curve

# base58 alphabet
alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

def sha256(arg) :
	byte_array = bytearray.fromhex(arg)
	m = hashlib.sha256()
	m.update(byte_array)
	return m.hexdigest()
 
def ripemd160(arg) :
  byte_array = bytearray.fromhex(arg)
  m = hashlib.new('ripemd160')
  m.update(byte_array)
  return m.hexdigest()

def b58encode(hex_string) :
	num = int(hex_string, 16)
	encode = ""
	base_count = len(alphabet)
	while (num > 0) :
		num, res = divmod(num,base_count)
		encode = alphabet[res] + encode
	return encode

def privToWif(priv) :
	_priv = priv.lower()
	priv_add_xEF = "EF" + _priv
	first_sha256 = sha256(priv_add_xEF)
	seconf_sha256 = sha256(first_sha256)
	first_4_bytes = seconf_sha256[0:8]
	resulting_hex = priv_add_xEF + first_4_bytes
	result_wif = b58encode(resulting_hex)
	return result_wif

def create_private_key(s):
    random.seed(s)
    randomNumber = random.randint(0, 2**256 - 1)
    prKey = hex(randomNumber)
    # print("prKey: " + str(prKey))
    if(len(prKey)<66):
        prKey = prKey[2:].zfill(64)

    # print("private Key: " + str(prKey[2:]))
    wif = privToWif(prKey[2:])
    # print("Wif private Key: " + str(wif))
    return randomNumber, wif

def create_public_address(private_key):
    # get x and y from curve 256k1
    pub_keys = keys.get_public_key(private_key,curve.secp256k1)
    #concat x and y
    pubKey=hex(pub_keys.x)[2:]+hex(pub_keys.y)[2:]
    # add test net
    pubKey='04'+pubKey
    len_pubKey=len(pubKey)
    if len_pubKey%2!=0:
        pubKey=pubKey+'0'
    # print("public Key: " + str(pubKey))

    digest = sha256(pubKey)
    digest1 = ripemd160(digest)
    tempDigest = "6F" + digest1
    digest2 = sha256(tempDigest)
    digest3 = sha256(digest2)

    output = "6F" + digest1 + digest3[:8]
    address = base58check.b58encode(bytes.fromhex(output))
    # print("public address: " + str(address.decode("utf-8")))
    return address.decode("utf-8")

def vanity_address_generator(first_chars):
  l = len(first_chars)
  # c = 0
  while(True):
    rnd, wif = create_private_key(random.randint(0,2**64))
    address = create_public_address(rnd)
    if address[1: 1+l] == first_chars:
      print("private key: ", wif)
      print("public key: ", address)
      break;
    # c += 1
    # if c%20 == 0:
    #   print("counter: ", c, "public key: ", address)

vanity_address_generator("rft")
# -*- coding: utf-8 -*-
"""q1_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17pTpbpOMAdsOZi3MrHDnKQmQFIluHiyy
"""

#!apt-get install libgmp-dev
#!pip install fastecdsa
#!pip install base58check

import random,hashlib,base58check
from fastecdsa import keys,curve

# base58 alphabet
alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

def sha256(arg) :
	byte_array = bytearray.fromhex(arg)
	m = hashlib.sha256()
	m.update(byte_array)
	return m.hexdigest()
 
def ripemd160(arg) :
  byte_array = bytearray.fromhex(arg)
  m = hashlib.new('ripemd160')
  m.update(byte_array)
  return m.hexdigest()

def b58encode(hex_string) :
	num = int(hex_string, 16)
	encode = ""
	base_count = len(alphabet)
	while (num > 0) :
		num, res = divmod(num,base_count)
		encode = alphabet[res] + encode
	return encode

def privToWif(priv) :
	_priv = priv.lower()
	priv_add_xEF = "EF" + _priv
	first_sha256 = sha256(priv_add_xEF)
	second_sha256 = sha256(first_sha256)
	first_4_bytes = second_sha256[0:8]
	resulting_hex = priv_add_xEF + first_4_bytes
	result_wif = b58encode(resulting_hex)
	return result_wif

def create_private_key(s):
    random.seed(s)
    randomNumber = random.randint(0, 2**256 - 1)
    prKey = hex(randomNumber)
    print("prKey: " + str(prKey))
    if(len(prKey)<66):
        prKey = prKey[2:].zfill(64)

    # print("private Key: " + str(prKey[2:]))
    wif = privToWif(prKey[2:])
    print("Wif private Key: " + str(wif))
    return randomNumber, wif

def create_public_address(private_key):
    # get x and y from curve 256k1
    pub_keys = keys.get_public_key(private_key,curve.secp256k1)
    #concat x and y
    pubKey=hex(pub_keys.x)[2:]+hex(pub_keys.y)[2:]
    # add test net
    pubKey='04'+pubKey
    len_pubKey=len(pubKey)
    if len_pubKey%2!=0:
        pubKey=pubKey+'0'
    # print("public Key: " + str(pubKey))
    
    digest = sha256(pubKey)
    digest1 = ripemd160(digest)
    tempDigest = "6F" + digest1
    digest2 = sha256(tempDigest)
    digest3 = sha256(digest2)
    output = "6F" + digest1 + digest3[:8]

    address = base58check.b58encode(bytes.fromhex(output))
    # print("public address: " + str(address.decode("utf-8")))
    return address.decode("utf-8")

print("wallet address:", create_public_address(create_private_key(268)[0]))